#!/usr/bin/env python
# coding:utf-8

'''
WEEELAB_BOT - Telegram bot.
Author: God
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
NOTE: The print commands are only for debug.
'''
# system library needed to read the environment variables
import os

# library to make requests to telegram server
import requests
# library to make requests to owncloud server, more details on https://github.com/owncloud/pyocclient
import owncloud
# library to handle time
import datetime
from datetime import timedelta
# library to handle dictionary
import operator

# get environment variables
OC_URL = os.environ.get('OC_URL') # url of the owncloud server
OC_USER = os.environ.get('OC_USER')  # OwnCloud username
OC_PWD = os.environ.get('OC_PWD') # OwnCloud password
OC_PATH = os.environ.get('OC_PATH') # path of the file to read in owncloud (/folder/file.txt)
TOKEN_BOT = os.environ.get('TOKEN_BOT') # Telegram token for the bot API
USER_LIST_NAME = os.environ.get('USER_LIST_NAME') # Python list of the user allowed to use the bot
USER_LIST_ID = os.environ.get('USER_LIST_ID') # Python list of the users' id allowed to use the bot
USER_BOT_PATH = os.environ.get('USER_BOT_PATH') # path of the file to store bot users in owncloud (/folder/file.txt)

# class with function used by the bot
class BotHandler:
    '''init function to set bot token and reference url'''
    def __init__(self, token):
        self.token = token # set token
        self.api_url = "https://api.telegram.org/bot{}/".format(token) # set bot url from the token

    '''function to get the last message send by the user to the bot
    for more info about this method refeer to https://core.telegram.org/bots/api#getting-updates'''
    def get_updates(self, offset=None, timeout=30):
        method = 'getUpdates' # set type of method used refering to Telegram API
        # set parameter like timeout in seconds for long polling and no offset related to updates
        params = {'timeout': timeout, 'offset': offset} 
        # make the request to the bot with the previous method and parameters, get type because we request a message
        resp = requests.get(self.api_url + method, params) 
        # store the json response from the telegram server
        result_json = resp.json()['result'] 
        return result_json  # return a variable of type json as response of the bot

    '''function to send messages to the user of the bot
    for more info about this method refeer to https://core.telegram.org/bots/api#sendmessage'''
    def send_message(self, chat_id, text):
        # set parameter like the unique identifier of the chat between user and bot and the message to send
        params = {'chat_id': chat_id, 'text': text}     
        method = 'sendMessage'  # set the method used refering to Telegram API
        # make the request to the bot with the previous method and parameters, post type because we send a message
        resp = requests.post(self.api_url + method, params)
        return resp # return a variable of type json as response of the bot

    '''function to get last message if there is'''
    def get_last_update(self):
        get_result = self.get_updates() # recall the function to get updates
        if len(get_result) > 0: # check if there are new messages
            last_update = get_result[-1]  # takes the last update from the result of the function
            return last_update # return the last message in json format
        else:
            return -1 # in case of error return an error code used in the main function

'''function created by Ste (teschio) complete code at https://github.com/WEEE-Open/weeelab
extract the name and surname from a string of type name.surname to obtain Name Surname'''
def nameExtr(username):
    firstName = username.split('.')[0].capitalize() # Extract the name and capitalize it
    lastName = username.split('.')[1].capitalize() # Extract the surname and capitalize it
    return firstName + " " + lastName # Return a string of type "Name Surname"

# set variable used in main function
weee_bot = BotHandler(TOKEN_BOT) # create the bot object

'''main function of the bot'''
def main():
    oc = owncloud.Client(OC_URL) # create an object of type Client to connect to the cloud url
    oc.login(OC_USER, OC_PWD) # connect to the cloud using authorize username and password
    new_offset = None # set at beginning an offset None for the get_updates function

    while True:
        weee_bot.get_updates(new_offset) # call the function to check if there are new messages
        last_update = weee_bot.get_last_update() # takes the last message from the server
        '''Variables for /inlab command'''
        people_inlab = 0
        found_user_inlab = False
        '''Variables for /log command'''
        lines_to_print = 5  # default line number to send
        '''Variables for /stat command'''
        user_hours = 0  # initialize hour variable, type int
        user_minutes = 0 # initialize minute variable, type int
        total_hours = 0 
        total_minutes = 0
        hours_sum = datetime.timedelta(hours=user_hours, minutes=user_minutes) # initialize hours sum variable, type datetime 
        ''' Variables for /top command'''
        users_name = []
        users_hours = {}
        top_list_print = 'Top User List!\n'
        position = 0
        number_top_list = 10  # Inizialize the number of users to print for command /top

        if last_update != -1: 
            try: 
                log_file = oc.get_file_contents(OC_PATH) # log file stored in owncloud server
                log_lines = log_file.splitlines()
                lines_inlab = [i for i, lines in enumerate(log_lines) if 'INLAB' in lines]
                # store the data of the last update of the log file, the data is in UTC so we add 2 for eu/it local time
                log_update_data = oc.file_info(OC_PATH).get_last_modified() + timedelta(hours=2)     
                last_update_id = last_update['update_id'] # store the id of the bot taken from the mesasge
                new_offset = last_update_id + 1 # store the update id of the bot
                command  = last_update['message']['text'].split() # store all the words in the message in an array (split by space)
                last_chat_id = last_update['message']['chat']['id'] # store the id of the chat between user and bot read from the message in a variable
                last_user_id = last_update['message']['from']['id'] # store the id of the user read from the message in a variable
                last_user_name = last_update['message']['from']['first_name'] # store the name of the user read from the message in a variable
                last_user_username = last_update['message']['from']['username'] # store the username of the user read from the message in a variable
                print last_update['message'] # DEBUG

            except KeyError: # catch the exception if raised
                print "ERROR!" # DEBUG

            if (last_user_username in USER_LIST_NAME) or (last_user_id in USER_LIST_ID): # check if the user is allowed to use the bot  
                ''' ADD COMMANDS HERE '''
                # Show how many students are in lab right now
                ''' Command "/inlab", Show the number of people in lab.
                    Command "/inlab who", Show the name of the people in lab.
                '''
                if command[0] == "/inlab" or command[0] == "/inlab@weeelab_bot": # Check if the message is the command /inlab
                    if (len(command) == 1): # Check if the command has option "who" or not
                        people_inlab=log_file.count("INLAB")
                        if people_inlab == 0: # Check if there aren't people in lab
                            # Send a message to the user that makes the request /inlab
                            weee_bot.send_message(last_chat_id, 'Nobody is in lab right now.') 
                        elif people_inlab == 1:
                            weee_bot.send_message(last_chat_id, 'There is one student in lab right now.') 
                        else:
                            weee_bot.send_message(last_chat_id, 'There are {} students in lab right now.'.format(people_inlab)) 
                    elif (command[1] == "who"): # Check if the command has option "who" or not
                        for index in lines_inlab:
                            found_user_inlab = True
                            user_inlab = nameExtr(log_file[index][47:log_file[index].rfind(">")]) # extract the name of the person
                            weee_bot.send_message(last_chat_id, '{}'.format(user_inlab)) 
                        if not found_user_inlab: 
                            weee_bot.send_message(last_chat_id, 'Nobody is in lab right now.')

                # Show log file
                ''' Command "/log", Show the complete OC_PATH file (only for admin user, by default only 5 lines)
                    Command "/log [number]", Show the [number] most recent lines of OC_PATH file
                    Command "/log all", Show all lines of OC_PATH file.
                '''
                if command[0] == "/log" or command[0] == "/log@weeelab_bot": # Check if the message is the command /log
                    log_print = ('Latest log update: {}\n \n'.format(log_update_data)) # write in the log variabile the data
                    if (len(command) > 1 and command[1].isdigit()): # check if the command is "/log [number]"
                        lines_to_print = int(command[1])
                    elif (len(command) > 1 and command[1] == "all"): # check if the command is "/log all"
                        lines_to_print = len(log_lines)
                    for lines_printed in range(1,lines_to_print):
                        log_print = log_print + '{}\n'.format(log_lines[lines_printed])
                    weee_bot.send_message(last_chat_id, '{}'.format(log_print))

                # Show data update log
                ''' Command "/sync", Show last edit date and time of the OC_PATH file.
                '''
                if command[0] == "/sync" or command[0] == "/sync@weeelab_bot": # Check if the message is the command /sync
                    weee_bot.send_message(last_chat_id, 'Latest log update:\n{}'.format(log_update_data)) 

                # Show the stat of the user
                ''' Command "/stat name.surname", Show hours spent in lab by name.surname user.
                '''
                if command[0] == "/stat" or command[0] == "/stat@weeelab_bot": # Check if the message is the command /stat
                    found_user = False # create a control variable used to check if name.surname is found

                    if (len(command) == 1):  # Check if the command has option or not
                        weee_bot.send_message(last_chat_id, 'Achtung! Insert name.surname to view the stats')
                    else:
                        user_name = str(command[1]) # store the option in a variable
                        for lines in log_lines:
                            if not ("INLAB" in lines) and (user_name == lines[47:lines.rfind(">")]):
                                found_user = True
                                # extract the hours and minute from char 39 until ], splitted by :
                                (user_hours, user_minutes) = lines[39:lines.rfind("]")].split(':')
                                # convert hours and minutes in datetime type
                                partial_hours = datetime.timedelta(hours=int(user_hours), minutes=int(user_minutes)) 
                                hours_sum += partial_hours # sum to the previous hours 
                        if not found_user:
                            weee_bot.send_message(last_chat_id, 'No statistics for the given user. Have you typed it correctly? (name.surname)')      
                        else:
                            total_second = hours_sum.total_seconds()
                            total_hours = int(total_second // 3600)
                            total_minutes = int((total_second % 3600) // 60)
                            weee_bot.send_message(last_chat_id, 'Stat for the user {}\nHH:MM = {:02d}:{:02d}'.format(nameExtr(user_name), total_hours, total_minutes))
                            # write the stat of the user

                # Show the top list of the users
                ''' Command "/top", Show a list of the top users in lab (defaul top 10).
                    Command "/top number", Show the top N elements.
                    Command "/top all", Show list with all users.
                '''
                if command[0] == "/top" or command[0] == "/top@weeelab_bot": # Check if the message is the command /top
                    if len(command) > 1 and command[1].isdigit(): # Check if the option is a number
                        number_top_list = int(command[1]) # set the number of user to print with the option
                    elif len(command) > 1 and command[1] == "all": # Check if the option is "all"
                        number_top_list = 50  # set the number of user to print to a "huge" number
                    for lines in log_lines:
                        if not ("INLAB" in lines):
                            name = lines[47:lines.rfind(">")].encode('utf-8') 
                            (user_hours, user_minutes) = lines[39:lines.rfind("]")].split(':')
                            partial_hours = datetime.timedelta(hours=int(user_hours), minutes=int(user_minutes)) 
                            if (name in users_name): # check if user was already found
                                users_hours[name] += partial_hours # add to the key with the same name the value partial_hours
                            else:
                                users_name.append(name) # create a new key with the name
                                users_hours[name] = partial_hours # add the hours to the key
                    # sort the dict by value in descendet order 
                    sorted_top_list = sorted(users_hours.items(), key=operator.itemgetter(1), reverse=True) 
                    for rival in sorted_top_list: # print the elements sorted
                        position += 1 # update the counter of position on top list
                        if position  <= number_top_list: # check if the list is completed
                            # extract the hours and minutes from dict, splitted by :
                            total_second = rival[1].total_seconds()
                            total_hours = int(total_second // 3600)
                            total_minutes = int((total_second % 3600) // 60)
                            # add the user to the top list
                            top_list_print = top_list_print + '{}) [{:02d}:{:02d}] {}\n'.format(position, total_hours, total_minutes, nameExtr(rival[0]))
                    weee_bot.send_message(last_chat_id, '{}'.format(top_list_print)) # send the top list to the user that makes the request
                # Show help
                ''' Command "/help", Show an help.
                '''
                if command[0] == "/help" or command[0] == "/help@weeelab_bot": # Check if the message is the command /help
                    help_message = "/start the bot and type /[COMMAND] [OPTION]. \n \
                    Available commands:\n \
                    inlab : Show the number of people in lab. \n \
                    log : Show the complete OC_PATH file (only for admin user, by default only 5 lines) \n \
                    [number] : Show the [number] most recent lines of OC_PATH file. \n \
                    all : Show all lines of OC_PATH file. \n \
                    stat name.surname : Show hours spent in lab by this user. \n \
                    top : Show a list of top users in lab (defaul top 10) \n \
                    [number] : Show the top [number] elements. \n \
                    all : Show list with all users. \n \
                    sync : Show last edit date and time of the OC_PATH file.\n \
                    help :  Show all the commands and a short explanations."
                    weee_bot.send_message(last_chat_id, '{}'.format(help_message))
            else:
                weee_bot.send_message(last_chat_id, 'Sorry! You are not allowed to use this bot \n Please contact WeeeOpen team to be authorized.')

            user_bot_contents = oc.get_file_contents(USER_BOT_PATH) # read the content of the user file stored in owncloud server
            if (str(last_user_id) in user_bot_contents): # Check if the user is already recorded
                pass
            else:
                # Store a new user name and id in a file on owncloud server, encoding in utf.8
                user_bot_contents = user_bot_contents.decode('utf-8') + '\'' + last_user_name.encode('utf-8') + '\'' + ': ' + '\'' + str(last_user_id) + '\'' + ', '   
                oc.put_file_contents(USER_BOT_PATH, user_bot_contents.encode('utf-8')) # write on the file the new data

# call the main() until a keyboard interrupt is called
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        exit()
